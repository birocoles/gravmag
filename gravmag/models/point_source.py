"""
This code presents a general approach for implementing the gravitational
magnetic induction fields produced by point sources.
"""

import numpy as np
from .. import check
from .. import utils
from .. import constants as cts
from .. import inverse_distance as id


def grav(coordinates, sources, mass, field, scale=True):
    """
    Gravitational potential, first and second derivatives
    produced by point sources in Cartesian coordinates.
    All values are referred to a topocentric Cartesian system with axes
    x, y and z pointing to north, east and down, respectively.

    Parameters
    ----------
    coordinates : 2d-array
        2d-array containing x (first line), y (second line), and z (third line) of
        the computation points. All coordinates should be in meters.
    sources : 2d-array
        2d-array containing the coordinates of the dipoles. Each line must contain
        the coordinates x, y and z of a single point source.
        All coordinates should be in meters.
    mass : 1d-array
        1d-array containing the mass of each point source in kg.
    field : str
        Gravitational field to be computed.
        The available fields are:

        - Gravitational potential: ``potential`` (in m² / s²)
        - z-component of acceleration: ``z`` (in mGal)
        - y-component of acceleration: ``y`` (in mGal)
        - x-component of acceleration: ``x`` (in mGal)
        - zz-component of acceleration: ``zz`` (in Eötvös)
        - yz-component of acceleration: ``yz`` (in Eötvös)
        - xz-component of acceleration: ``xz`` (in Eötvös)
        - yy-component of acceleration: ``yy`` (in Eötvös)
        - xy-component of acceleration: ``xy`` (in Eötvös)
        - xx-component of acceleration: ``xx`` (in Eötvös)
     scale : boolean
        Defines if the resultant field will be multiplied by scale factors
        "constants.GRAVITATIONAL_CONST" (Gravitational constant),
        "constants.SI2MGAL" (constant tranforming from m/s² to mGal) or
        "constants.SI2EOTVOS" (constant tranforming from 1/s² to Eötvos)

    Returns
    -------
    result : array
        Gravitational field generated by the spheres at the computation points.

    """

    if check_input is True:
        check.coordinates(coordinates)
        check.coordinates(sources)
        check.scalar_prop(mass)
        # check if field is valid
        if field not in [
            "potential",
            "x",
            "y",
            "z",
            "xx",
            "xy",
            "xz",
            "yy",
            "yz",
            "zz",
        ]:
            raise ValueError("invalid field {}".format(field))

    # compute Squared Euclidean Distance Matrix (SEDM)
    R2 = id.sedm(coordinates, sources, check_input=False)

    # compute the kernel matrix according to "field"
    if field is "potential":
        G = 1.0 / np.sqrt(R2)
    elif field in ["x", "y", "z"]:
        G = id.grad(coordinates, sources, R2, [field], False)[0]
    else:  # field is in ["xx", "xy", "xz", "yy", "yz", "zz"]
        G = id.grad_tensor(coordinates, sources, R2, [field], False)[0]

    # compute the potential field
    result = G @ mass

    # multiply the computed field by the corresponding scale factors
    if scale is True:
        result *= cts.GRAVITATIONAL_CONST
        # Convert from m/s^2 to mGal
        if field in ["x", "y", "z"]:
            result *= cts.SI2MGAL
        # Convert from 1/s^2 to Eötvös
        if field in ["xx", "xy", "xz", "yy", "yz", "zz"]:
            result *= cts.SI2EOTVOS

    return result


def mag(coordinates, sources, moment, field, scale=True):
    """
    Magnetic scalar potential and magnetic induction components
    produced by point sources in Cartesian coordinates.
    All values are referred to a topocentric Cartesian system with axes
    x, y and z pointing to north, east and down, respectively.

    Parameters
    ----------
    coordinates : 2d-array
        2d-array containing x (first line), y (second line), and z (third line) of
        the computation points. All coordinates should be in meters.
    sources : 2d-array
        2d-array containing the coordinates of the point sources. Each line must contain
        the coordinates of a single point source in the following order:
        south (x1), north (x2), west (y1), east (y2), top (z1) and bottom (z2).
        All coordinates should be in meters.
    moment : 2d-array
        2d-array containing the total-magnetization components of the prisms.
        Each line must contain the intensity (in A m²), inclination and
        declination (in degrees) of the total magnetic moment of a single prism.
    field : str
        Magnetic field to be computed.
        The available fields are:

        - Magnetic scalar potential: ``potential`` (in uT x m)
        - z-component of induction: ``z`` (in nT)
        - y-component of induction: ``y`` (in nT)
        - x-component of induction: ``x`` (in nT)
    scale : boolean
       Defines if the resultant field will be multiplied by scale factors
       "constants.CM" (Magnetic constant),
       "constants.T2MT" (constant tranforming from Tesla to microtesla) or
       "constants.T2NT" (constant tranforming from Tesla to nanotesla)

    Returns
    -------
    result : array
        Magnetic field generated by the point sources at the computation points.

    """

    # Verify the input parameters
    check.coordinates(coordinates)
    check.magnetization(moment, sources)

    # check if field is valid
    if field not in ["potential", "x", "y", "z"]:
        raise ValueError("invalid field {}".format(field))

    # Compute the Cartesian components of total-moment
    mx, my, mz = utils.magnetization_components(moment)

    # compute Squared Euclidean Distance Matrix (SEDM)
    # sources must be transposed because its shape is transposed
    # with respect to coordinates
    R2 = id.sedm(coordinates, sources.T, check_input=False)

    # compute the kernel matrix according to "field"
    if field is "potential":
        Gx, Gy, Gz = id.grad(
            data_points=coordinates,
            source_points=sources.T,
            SEDM=R2,
            components=["x", "y", "z"],
            check_input=False,
        )
        G = -(mx * Gx + my * Gy + mz * Gz)
    elif field is "x":
        Gxx, Gxy, Gxz = id.grad_tensor(
            data_points=coordinates,
            source_points=sources.T,
            SEDM=R2,
            components=["xx", "xy", "xz"],
            check_input=False,
        )
        G = mx * Gxx + my * Gxy + mz * Gxz
    elif field is "y":
        Gxy, Gyy, Gyz = id.grad_tensor(
            data_points=coordinates,
            source_points=sources.T,
            SEDM=R2,
            components=["xy", "yy", "yz"],
            check_input=False,
        )
        G = mx * Gxy + my * Gyy + mz * Gyz
    else:  # field is "z"
        Gxz, Gyz, Gzz = id.grad_tensor(
            data_points=coordinates,
            source_points=sources.T,
            SEDM=R2,
            components=["xz", "yz", "zz"],
            check_input=False,
        )
        G = mx * Gxz + my * Gyz + mz * Gzz

    # compute the potential field
    result = np.sum(G, axis=1)

    # multiply the computed field by the corresponding scale factors
    if scale is True:
        result *= cts.CM
        # Convert from T to nT
        if field in ["x", "y", "z"]:
            result *= cts.T2NT
        # Convert from T to uT and change sign
        if field == "potential":
            result *= -cts.T2MT

    return result
